# 0.실험 목적

    1.Data Sheet 및 Reference Manual을 참고하여 해당 레지스터 및 주소에 대한 설정 이해
    2.IAR EW에서 프로젝트 생성 후 관련 설정 변경
    3.조이스틱을 이용한 LED 제어
    > UP   :PD7 LED On 나머지 OFF
    > LEFT :PD4 LED On 나머지 OFF
    > DOWN :PD3 LED On 나머지 OFF
    > RIGHT:PD2 LED On 나머지 OFF
    > 중립(Selection 아님): 모든 LED OFF

    4.정상적인 동작 유무 확인

##
# 1. 배경 지식

## 1.1 volatile 변수 
    변수를 선언할 때 앞에 volatile keyword를 붙이면 컴파일러에서
    해당 변수를 최적화에서 제외하게끔 만 들어 항상 메모리에 접근하도록 만든다.
    주로 개발자가 설정한 개념을 구현하기 위해 코딩된 프로그램을 
    온전히 컴파일 되도록 하게끔 만들 때 사용한다.
    volatile 변수를 참조할 경우, 
    레지스터에 로드된 값을 사용하지 않고 매번 메모리를 참조하기 때문에,
    레지스터를 제어하기 위해 같은 주소에 값을 여러번 쓰는 경우가 많은 
    임베디드 시스템에서 주로 사용된다.
    예를 들면, 아래 코드에서는 3번의 메모리 쓰기가 모두 같은 주소에 이루어지고 있다. 
    이런 경우, 컴파일러에서는 최적화를 위해 마지막 코드만 실행하게 되는데 
    레지스터에 매번 값을 써서 동작시키는 경우에는 부적절하다
    
![그림1](https://user-images.githubusercontent.com/111568619/192113320-55142a67-4a0b-4304-bc15-89703000cef3.png)

    그러나 아래와 같이 volatile 키워드를 붙여주게 되면,
    컴파일러에서 최적화를 하지 않고 코드 각각을 수행하게 되어, 
    개발자가 의도한대로 레지스터에 값을 쓰는 명령을 각각 수행하게 된다.
    
![그림2](https://user-images.githubusercontent.com/111568619/192113326-65f744de-fbdc-48b4-9083-568941261f09.png)

## 1.2 Stm32 보드
    STMicornicsSTMicroelectronics에서 개발한 32bits MCU보드이다. 
    STM32 칩은 32비트 Arm 프로세서 코어를 기반으로 하는 관련 시리즈로 구성되어 있다. 
    내부적으로 각 마이크로 컨트롤러는 프로세서 코어, 정적 RAM,
    플래시 메모리 등의 다양한 장치로 구성되어 있으며,
    몇몇 교육기관에서 임베디드 교보재로 사용되기도 한다.
    
## 1.3 bitwise operation
    비트 연산이란, 이진수에 대해 비트 단위로 적용되는 연산을 뜻한다.
    비트 연산의 종류는 다음과 같다.
    > and( a&b ), or( a|b ), xor( a^b ), not( ~a ), shift( a>>b, a<<b )
    
    AND 연산의 경우, 두 이진수가 모두 1일 때만 1을 결과값으로 갖는다.
    > 예시) X & 0 == 0, X & 1 == X,  1 & 1 == 1, 0 & 0 == 0
    
    OR 연산의 경우, 두 이진수 중 하나만 1이면 1을 결과값으로 갖는다.
    > 예시) X | 0 == X, X | 1 == 1,  0 | 0 == 0
    
    XOR 연산의 경우, 두 이진수가 다를 경우만 1을 결과값으로 갖는다.
    > 예시) X ^ 0 == X, X ^ 1 == ~X
    
    NOT 연산의 경우, 이진수 값의 반대 결과를 결과값으로 갖는다.
    > 예시) ~0 = 1, ~1 = 0
    
    SHIFT 연상의 경우, A를 왼쪽/오른쪽으로 B만큼 이동시킨다.
    > 예시) 0b01011 << 1 == 0b10110, 0b01011 >> 1 == 0b00101
    
## 1.4 floating 상태와 Pullup/Pulldown resistor 

    직관적으로 생각하기에는 스위치가 닫히면 PIN에 1(HIGH)가, 
    열리면 0(LOW)의 값이 출력된다고 생각하기 쉽지만 실제로는 스위치가 열린 상태에서는 HIGH도, 
    LOW도 아닌 상태가 된다.
    이러한 상태를 플로팅(Floating) 상태라고 한다.
    플로팅 상태를 해결해 주어야 입출력이 가능해지는데 풀업(PULL-UP),
    풀다운(PULL-DOWN) 저항으로 이를 해결할 수 있다.
    풀업은 플로팅 상태일 때 값을 끌어올린다는 의미로, 
    저항을 VCC 단자에 달아주어 스위치가 열렸을 때(기존 플로팅 상태) 1의 출력을,
    닫혔을 때 0의 출력을 보내게끔 만든다. 
    반대로 풀다운은 플로팅 상태일 때 값을 끌어내린다는 의미로,
    저항을 GND 쪽에 달아주어 스위치가 열렸을 때 0의 출력을,
      닫혔을 때 1의 출력을 보내게끔 만든다.
    실험에 사용한 임베디드 보드(Cortex-M3)의 조이스틱의 경우,
    ‘풀업’ 저항을 사용하기 때문에 직관과는 다르게 입력되지 
    않았을 때 1의 출력을 내보내는 상태이므로 실험을 
    진행함에 있어서 이를 염두에 두고 진행해야 할 것이다.

# 2. 실험 과정
  ## 2.1 세부 실험 내용
    1. Datasheet 및 Reference Manual을 참고하여 해당 레지스터 및 주소에 대한 설정 이해
    2. IAR EW에서 프로젝트 생성 후 관련 설정 변경
    3. 조이스틱을 이용한 LED 제어
    
	  > Up	: PD 7 LED On 나머지 OFF
	  > Left	: PD 4 LED On 나머지 OFF
	  > Down	: PD 3 LED On 나머지 OFF
	  > Right	: PD 2 LED On 나머지 OFF
	  > 중립(selection 아님): 모든 LED OFF
    
    4. 정상적인 동작 유무 확인
    5. 오실로스코프를 이용한 디버깅(생략)
 ##2.1 실험 방법
    1. J-Link와 보드를 컴퓨터에 연결한다.
    
    2. IAR EW for Arm을 실행해 project 생성 및 기본 설정을 한다.
    
![22](https://user-images.githubusercontent.com/111568619/192113557-65e96c1d-a880-4f6c-bffe-71ab219d4207.png)

    3. 데이터시트와 레퍼런스 문서를 참고해 실험에 사용 될 레지스터를 찾아 정의한다.
    
![ㄴㄴ](https://user-images.githubusercontent.com/111568619/192113574-1c190f24-c5b6-4584-8c66-774fe5597b70.png)

    4. 위 레지스터들을 이용해 사용할 GPIO(조이스틱: GPIOC, LED: GPIOD)에 clock을 인가       
    하고 reset 및 각 GPIO의 input/output을 설정하는 코드를 작성한다.
    
    5. 완성된 코드를 보드에 업로드하고 전원을 껐다 켠 뒤 동작을 확인한다.
    
# 3. 실험 결과
    우리는 GPIO와 RCC를 이용한 코드 작성에 대한 편의성과 
    가독성을 높이기 위해 몇가지 래지스터에 대한 정의를 먼저 해주었다.
    
    ![ㄴㄴ](https://user-images.githubusercontent.com/111568619/192113652-54e15c90-9d21-45d9-a553-a144e8d84481.png)


    1.	RCC_APB2_ENR은 GPIO에 RCC를 enable하기 위해 필요한 레지스터이다.
    
    2.	GPIOD_CRL은 포트D에 대한 configuration과 기타 mode에 관한 레지스터이다.
    
    3.	GPIOD_BSRR의 set/reset를 조절하는 레지스터이다. 즉, LED에 빛을 켜고 끄는 역할을 한다.
    
    4.	GPIOD_BRR은 포트D에 대한 리셋을 하는 레지스터이다.
    
    5.	GPIOC_CRH는 조이스틱을 제어하는 포트C의 configuration 과 
    기타 mode설정에 관한 레지스터이다.
    
    6.	GPIOC_IDR 조이스틱을 제어하는 포트C의 출력 값에 관한 레지스터이다.
    
    아래부터는 위 정의에 따라 레지스터를 설명하겠다. 
    
    ![2](https://user-images.githubusercontent.com/111568619/192113660-826cae92-6882-4fa0-b2b7-4a5574769e7f.png)
    
    위 부분은 우리 조가 상당히 고생했던 부분인데 각 레지스터에 관한 리셋을 해주는 부분이다.
    
    ![3](https://user-images.githubusercontent.com/111568619/192113701-f01c024d-0d01-4daf-b5c4-26f07051e6d0.png)
    
    GPOPD_CRL = 0x10011100은 GPIO 포트D에 2,3,4,7번을 output모드로 설정한 것이다.
    
    GPIOC_CRH= 0x00444400은 조이스틱을 조절하야 LED를 조작해야 함으로 output모드로 설정함.
    
    GPIOD_BSRR = LED초기 설정값을 reset으로 해주어 시작시점에는 LED모두 소등 상태로 설정함

![4](https://user-images.githubusercontent.com/111568619/192113713-623a0c5b-1ed9-4c02-8890-2bf015764393.png)

    위 코드부터는 실질적으로 보드에서 조이스틱을 통해 입력 받아 LED를 켜주는 부분이다.
    조이스틱은 입력이 들어올 때 0이므로 각각의 조건에 not연산을 추가해주었다.
    또한 GPIOD_BRR을 통해 LED를 reset시켜주고 
    조이스틱을 통해 받은 입력 값에 따라 해당 LED포트만을    
    set 시켜주어 LED를 점등하는 방식으로 코드를 완성시켰다.
    우리3조의 보드 포팅 결과는 다음과 같다.
![1111](https://user-images.githubusercontent.com/111568619/192113765-f9086371-a767-46da-b0d2-c62115cd56bb.png)

<조이스틱의 조작에 따른 LED 점등 모습>

# 4. 결론

    이번 실험을 통해 Arm Stm32 개발보드를 레지스터 및 주소 제어를 통해 여러 모듈을 조작하는 법을익힐 수 있었다.
    또한 데이터 시트 및 레퍼런스 매뉴얼을 읽고 실제 C++ 코드에 적용하는 법을 배울수 있었다. 
    우리 조는 실험과정에서 보드의 LED 제어부터 실패하여 어려움을 겪고 정규 실험시간 내에 실험을 완수하지 못하였으나, 
    초기화 문제임을 지적 받고 어렵지 않게 주어진 실험 과제를 해결할 수 있었다.


